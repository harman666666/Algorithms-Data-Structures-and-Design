
SCRAPE AND WRITE NOTES FOR FOLLOWING: https://www.geeksforgeeks.org/number-theory-competitive-programming/#basics
SCRAPE AND WRITE NOTES FOR FOLLOWING: https://medium.com/algorithms-and-leetcode/math-related-problems-on-leetcode-9537df481fbe

1) Greatest Common Divisor and Least Common Multiple

        The GCD (Greatest Common Divisor) of two numbers is defined 
        as the largest integers 
        that divides both the numbers. For example, 2 is the GCD of 4 and 6. 
        From this concept, 
        follows something called co-primes. Two numbers are said to be 
        co-primes if their GCD is 1. 
        For example, 3 and 5 are co-primes because their GCD is 1.

        Coming to LCM (Least Common Multiple), it is defined as the 
        smallest integer that is divisible by both the numbers. 
        For example, 10 is the LCM of 2 and 5.

        Given any two numbers a and b,
        gcd(a, b) = a*b / lcm(a, b)

        Facts:
        gcd(a, b) = gcd(a, b - a)
        gcd(a, 0) = a
        gcd(a, b) is the smallest positive number in {ax + by | x, y in integers}

2) Euclids algo to get GCD and LCM
    A simple implementation of Euclid's GCD algorithm in C++ would be,

        int gcd(int a,int b)
        {
            return b==0?a:gcd(b,a%b);
        }
        Once we calculate the GCD of two numbers, we can calculate the LCM very easily.

        int lcm(int a,int b)
        {
            return (a*b)/gcd(a,b);
        }

        If a is smaller than b, the first step of the algorithm swaps the numbers. 
        For example, if a < b, the initial quotient is zero and the remainder is a. 
        Thus, rk is smaller than it's predecessor rk-1.
        Since the remainders decrease with every iteration, a remainder rN must eventually equal 0, 
        at which point this algorithm stops. The final non-zero remainder rN-1 
        is the greatest common divisor for a and b.

        g = gcd(a, b) = gcd(b, r0) = gcd(r0, r1) = … = gcd(rN−2, rN−1) = rN−1.


3) Prime Number Detection:
        we can reduce the loop even further to check until sqrt(n) for any possible divisors. The implementation would be,

        bool isPrime(int x)
        {
            for(int i=0;i*i<=x;i++)
            {
                if(x%i == 0)
                    return false;
            }
            return true;
        }

        Notice that in this implementation, we hit only half the number of proper divisors.
        There are many more algorithms for primality test like 
        Fermat's little theorem, Miller-Rabin test, Solovay-Strassen 

4) Sieve of Eratosthenes

        In mathematics, the Sieve of Eratosthenes is a very 
        simple algorithm of finding all prime numbers upto a given limit.

        In this algorithm, we start from the number 2 and keep marking the 
        composites which are the multiples of a prime. For example, if we were trying 
        to find the primes below 11. Let the flag array be initialized to zero. The 
        flag array signifies the compositeness of each number. 
        It is set to 1 if it is a composite number, otherwise zero.

        As you can notice that after iteration 1, all numbers which are the multiples of 2 
        have been set to 1, implying that they are composite numbers. When we move to iteration 2, 
        all multiples of 3 have been marked composite. Notice that we do not change the mark of 2 
        and 3, since they weren't multiples of any smaller number, thus implying that they are primes. 
        Once all the numbers have been visited once, we loop through the flag array and filter 
        out the numbers with flag value set to 0. This gives us all the primes in the range.

        //Finding all primes within the range [1,n)
        void sieve(int n)
        {
            vector<int> flag(n,0);
            flag[0] = flag[1] = 1;              //Setting 0 and 1 as composites.
            //Finding the primes.
            for(int i=2;i<n;i++)                //Running a loop from 2 to n-1.
            {
                if(flag[i]==0)                  //Found a prime.
                {
                    for(int j=2*i;j<n;j+=i)     //looping through the multiples of the prime.
                        flag[j] = 1;            //Setting flag to composite.
                }
            }
            //Printing the primes.
            for(int i=0;i<n;i++)
            {
                if(flag[i]==0)
                    cout << i << " ";
            }
            cout << endl;
        }


5)  Congruence and Modulu Operation:
    x = y (mod n) means x and y have the same 
    remainder when divided by n
    
5.1) Modulo Multiplicative inverse:

    x^-1 is the inverse of x mod n if x*x?^-1  = 1 (mod n)

    5^-1 = 3 ( mod 7) because 5*3 = 15 = 1 (mod 7)
    May not exist => inverse of 2 mod 4
    Exists iff gcd(x, n) = 1

    All intermediate nums calcualted by Euclidean algo are 
    integer combinations of a and b:
    - Therefore, gcd(a, b) = ax + by for some integers x,y 
    - If gcd(a, n) = 1 then ax + ny = 1 for some x, y
    - Taking modulo n gives ax = 1 (mod n)
    -> We are done finding multiplicative inverse if we can find
        such x and y

5.2) Extended Euclidean Algorithm:
    ax + by = gcd(a, b) => Bezout's identity
    Keep the original algo but write all the intermediate numbers
    as integer combinations of a and b
    
    function extended_gcd(a, b)
        s := 0;    old_s := 1
        t := 1;    old_t := 0
        r := b;    old_r := a
        
        while r ≠ 0
            quotient := old_r div r
            (old_r, r) := (r, old_r - quotient * r) # this is gcd
            (old_s, s) := (s, old_s - quotient * s) # this is a
            (old_t, t) := (t, old_t - quotient * t) # this is b
        
        output "Bézout coefficients:", (old_s, old_t)
        output "greatest common divisor:", old_r
        output "quotients by the gcd:", (t, s)

5.3) Chinese remainder thrm:
        Given a, b, m, n with gcd(m, n) = 1
        Find x with x = a (mod m) and x = b (mod n)

        Soln: 
            - Let n^-1 be the inverse of n mod m
            - Let m^-1 be the inverse of m mod n
            - Set x = a*n*n^-1 + b*m*m^-1
        Extension: solve for simultaneous equations

5.4) n choose k. 
     Same as the coefficient of 
     (x^k)*(y^n-k) in the expansion of (x + y)^n
    -> Use pascals triangle
5.45) MATRIX MULTIPLCATION IS ROW OF FIRST MAT * COL OF SECOND MAT

5.5) Fibonnaci closed form: (Any linear recurrence closed form)
    [Fn+1, Fn] = [1 1, 1 0]* [Fn, Fn-1] = [1 1, 1 0]^n * [F1, F0]
    -> Comma means row split for matrix!
    -> USE FAST EXPONENTIAION to compute matrix power
    -> Can be extended to support any linear recurrence with 
    cosntant coefficents. 

5.6) Gemometry problems: DONT USE FLOATING POINT. 
     AVOID DIVISION WHENEVER POSSIBLE
    Have vector <x, y>

     Norm of vector is sqrt(x^2 + y^2)
     Counter clockwise rotation by x:
     [cos x  -sin x, sin x  cos x]*[x, y]
    Normal vectors are: (y, -x) and (-y, x)


5.7) Line Line intersection: 
    Have two lines:
    ax + by + c = 0 and dx + ey + f = 0
    Write in mat form:
    [a b, d e] [x, y] = -[c, f]
    Left multiply by matrix inverse:

    => 1/(ae - bd) * [e -b, -d a] 

    -> When ae = bd -> the lines coincide or are parallel: 
            EDGE CASE CHECK FOR THIS

5.8) Circumcircle of a Triangle:
    Have three points A, B, C:
    want to compute P that is equidistant from A, B, C
    Dont solve system of quadratic equations
    Do following:
        - Find the equations of the bisectors of AB and BC
        - Compute their intersection!!!

5.9) Have three points A, B, C. 
    Want to compute the area S of trangle ABC
    Use cross product: 2S = |(B-A) x (C-A)|

 

6.0) CROSS PRODUCT COMPUTATION!

    (x1, y1) x (x2, y2) = |x1 x2, y1 y2| = x1y2 - x2y1
    -> Very important

6.1) AREA OF A SIMPLE POLYGON:

    Given vertices P1, P2, ..., Pn of polygon P
    Want to compute the area S of P
    If P is convex, we can decomponse P into triangles: 

    2S = |Sum_from_i=2_to_n-1[(P_i+1 - P_1) x (P_i - P_1)]|

    -> turns out, this formula works for non-convex polygons too
        - area is the absolute value of the sum of the "signed" area
    -> Alternative formulat (xn+1 = x1, yn+1 = y1):

        2S = |Sum_from_i=1_to_n[xi*yi+1 - xi+1*yi]



6.5) Add computational geometry notes from hackerearth here

7) Go to notes folder and add number theory notes here

8) Read uni lecture slides for math add here

9) MEMORIZE ITERTOOLS FOR PYTHON!


10) is Prime in python:
    remove all prime numbers from a linked list. 
    (no mention of how large numbers could be)

    def isprime(n):
        return all(n%i !=0 for i in xrange(2, math.sqrt(n)+1) ) if n > 0 else False

    def remove(head):
        if not head: return None
        head.next = remove(head.next)
        return head.next if isprime(head.val) else head

11) SUM OF POWERS TECHNIQUE

    Sum of numbers from 1 to n -> (1/2) * n * (n+1)
    Sum of squares from 1 to n inclusive -> (1/6) * n * (n+1) * (2n + 1)
    Sum of cubes from 1 to n inclusive -> 
        (Sum of numbers from 1 to N) ^ 2 == ( (1/2)* n * (n+1)) ^ 2

12) FAST EXPONENTIATION TECHNIQUE:

    a^n = 1 if n == 0
    a^n = a if n == 1
    a^n = (a^(n/2))^2 is n is even
    a^n = a*(a^((n-1)/2) )^2 if n is odd
    => recursive implementation is O(log n)

13) Linear algebra:
    -> Solve system, invert a matrix, find the rank of matrix, compute determinant,
    -> all the above can be done with gaussian elimination

14)


