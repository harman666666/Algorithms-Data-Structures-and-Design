
SCRAPE AND WRITE NOTES FOR FOLLOWING: https://www.geeksforgeeks.org/number-theory-competitive-programming/#basics
SCRAPE AND WRITE NOTES FOR FOLLOWING: https://medium.com/algorithms-and-leetcode/math-related-problems-on-leetcode-9537df481fbe

WRITE NOTES ON COMPUTATIONAL GEOMETRY IN NOTES SECTION HERE.


1) Greatest Common Divisor and Least Common Multiple

        The GCD (Greatest Common Divisor) of two numbers is defined 
        as the largest integers 
        that divides both the numbers. For example, 2 is the GCD of 4 and 6. 
        From this concept, 
        follows something called co-primes. Two numbers are said to be 
        co-primes if their GCD is 1. 
        For example, 3 and 5 are co-primes because their GCD is 1.

        Coming to LCM (Least Common Multiple), it is defined as the 
        smallest integer that is divisible by both the numbers. 
        For example, 10 is the LCM of 2 and 5.

        Given any two numbers a and b,
        gcd(a, b) = a*b / lcm(a, b)

        Facts:
        gcd(a, b) = gcd(a, b - a)
        gcd(a, 0) = a
        gcd(a, b) is the smallest positive number in {ax + by | x, y in integers}

2) Euclids algo to get GCD and LCM
    A simple implementation of Euclid's GCD algorithm in C++ would be,

        int gcd(int a,int b)
        {
            return b==0?a:gcd(b,a%b);
        }
        Once we calculate the GCD of two numbers, we can calculate the LCM very easily.

        int lcm(int a,int b)
        {
            return (a*b)/gcd(a,b);
        }

        If a is smaller than b, the first step of the algorithm swaps the numbers. 
        For example, if a < b, the initial quotient is zero and the remainder is a. 
        Thus, rk is smaller than it's predecessor rk-1.
        Since the remainders decrease with every iteration, a remainder rN must eventually equal 0, 
        at which point this algorithm stops. The final non-zero remainder rN-1 
        is the greatest common divisor for a and b.

        g = gcd(a, b) = gcd(b, r0) = gcd(r0, r1) = … = gcd(rN−2, rN−1) = rN−1.


3) Prime Number Detection:
        we can reduce the loop even further to check until sqrt(n) for any possible divisors. The implementation would be,

        bool isPrime(int x)
        {
            for(int i=0;i*i<=x;i++)
            {
                if(x%i == 0)
                    return false;
            }
            return true;
        }

        Notice that in this implementation, we hit only half the number of proper divisors.
        There are many more algorithms for primality test like 
        Fermat's little theorem, Miller-Rabin test, Solovay-Strassen 

4) Sieve of Eratosthenes

        In mathematics, the Sieve of Eratosthenes is a very 
        simple algorithm of finding all prime numbers upto a given limit.

        In this algorithm, we start from the number 2 and keep marking the 
        composites which are the multiples of a prime. For example, if we were trying 
        to find the primes below 11. Let the flag array be initialized to zero. The 
        flag array signifies the compositeness of each number. 
        It is set to 1 if it is a composite number, otherwise zero.

        As you can notice that after iteration 1, all numbers which are the multiples of 2 
        have been set to 1, implying that they are composite numbers. When we move to iteration 2, 
        all multiples of 3 have been marked composite. Notice that we do not change the mark of 2 
        and 3, since they weren't multiples of any smaller number, thus implying that they are primes. 
        Once all the numbers have been visited once, we loop through the flag array and filter 
        out the numbers with flag value set to 0. This gives us all the primes in the range.

        //Finding all primes within the range [1,n)
        void sieve(int n)
        {
            vector<int> flag(n,0);
            flag[0] = flag[1] = 1;              //Setting 0 and 1 as composites.
            //Finding the primes.
            for(int i=2;i<n;i++)                //Running a loop from 2 to n-1.
            {
                if(flag[i]==0)                  //Found a prime.
                {
                    for(int j=2*i;j<n;j+=i)     //looping through the multiples of the prime.
                        flag[j] = 1;            //Setting flag to composite.
                }
            }
            //Printing the primes.
            for(int i=0;i<n;i++)
            {
                if(flag[i]==0)
                    cout << i << " ";
            }
            cout << endl;
        }


5)  Congruence and Modulu Operation:
    x = y (mod n) means x and y have the same 
    remainder when divided by n
    
5.1) Modulo Multiplicative inverse:

    x^-1 is the inverse of x mod n if x*x?^-1  = 1 (mod n)

    5^-1 = 3 ( mod 7) because 5*3 = 15 = 1 (mod 7)
    May not exist => inverse of 2 mod 4
    Exists iff gcd(x, n) = 1

    All intermediate nums calcualted by Euclidean algo are 
    integer combinations of a and b:
    - Therefore, gcd(a, b) = ax + by for some integers x,y 
    - If gcd(a, n) = 1 then ax + ny = 1 for some x, y
    - Taking modulo n gives ax = 1 (mod n)
    -> We are done finding multiplicative inverse if we can find
        such x and y

5.2) Extended Euclidean Algorithm:
    ax + by = gcd(a, b) => Bezout's identity
    Keep the original algo but write all the intermediate numbers
    as integer combinations of a and b
    
    function extended_gcd(a, b)
        s := 0;    old_s := 1
        t := 1;    old_t := 0
        r := b;    old_r := a
        
        while r ≠ 0
            quotient := old_r div r
            (old_r, r) := (r, old_r - quotient * r) # this is gcd
            (old_s, s) := (s, old_s - quotient * s) # this is a
            (old_t, t) := (t, old_t - quotient * t) # this is b
        
        output "Bézout coefficients:", (old_s, old_t)
        output "greatest common divisor:", old_r
        output "quotients by the gcd:", (t, s)

5.3) Chinese remainder thrm:
        Given a, b, m, n with gcd(m, n) = 1
        Find x with x = a (mod m) and x = b (mod n)

        Soln: 
            - Let n^-1 be the inverse of n mod m
            - Let m^-1 be the inverse of m mod n
            - Set x = a*n*n^-1 + b*m*m^-1
        Extension: solve for simultaneous equations

5.4) n choose k. 
     Same as the coefficient of 
     (x^k)*(y^n-k) in the expansion of (x + y)^n
    -> Use pascals triangle
5.45) MATRIX MULTIPLCATION IS ROW OF FIRST MAT * COL OF SECOND MAT

5.5) Fibonnaci closed form: (Any linear recurrence closed form)
    [Fn+1, Fn] = [1 1, 1 0]* [Fn, Fn-1] = [1 1, 1 0]^n * [F1, F0]
    -> Comma means row split for matrix!
    -> USE FAST EXPONENTIAION to compute matrix power
    -> Can be extended to support any linear recurrence with 
    cosntant coefficents. 

5.6) Gemometry problems: DONT USE FLOATING POINT. 
     AVOID DIVISION WHENEVER POSSIBLE
    Have vector <x, y>

     Norm of vector is sqrt(x^2 + y^2)
     Counter clockwise rotation by x:
     [cos x  -sin x, sin x  cos x]*[x, y]
    Normal vectors are: (y, -x) and (-y, x)


5.7) Line Line intersection: 
    Have two lines:
    ax + by + c = 0 and dx + ey + f = 0
    Write in mat form:
    [a b, 
    d e] [x, y] = -[c, f]
    Left multiply by matrix inverse:

    => 1/(ae - bd) * [e -b, -d a] 

    -> When ae = bd -> the lines coincide or are parallel: 
            EDGE CASE CHECK FOR THIS

5.8) Circumcircle of a Triangle:
    Have three points A, B, C:
    want to compute P that is equidistant from A, B, C
    Dont solve system of quadratic equations
    Do following:
        - Find the equations of the bisectors of AB and BC
        - Compute their intersection!!!

5.9) Have three points A, B, C. 
    Want to compute the area S of trangle ABC
    Use cross product: 2S = |(B-A) x (C-A)|

 

6.0) CROSS PRODUCT COMPUTATION!

    (x1, y1) x (x2, y2) = |x1 x2, y1 y2| = x1y2 - x2y1
    -> Very important

6.1) AREA OF A SIMPLE POLYGON:

    Given vertices P1, P2, ..., Pn of polygon P
    Want to compute the area S of P
    If P is convex, we can decomponse P into triangles: 

    2S = |Sum_from_i=2_to_n-1[(P_i+1 - P_1) x (P_i - P_1)]|

    -> turns out, this formula works for non-convex polygons too
        - area is the absolute value of the sum of the "signed" area
    -> Alternative formulat (xn+1 = x1, yn+1 = y1):

        2S = |Sum_from_i=1_to_n[xi*yi+1 - xi+1*yi]



6.5) Add computational geometry notes from hackerearth here

7) Go to notes folder and add number theory notes here

8) Read uni lecture slides for math add here

9) MEMORIZE ITERTOOLS FOR PYTHON!


10) is Prime in python:
    remove all prime numbers from a linked list. 
    (no mention of how large numbers could be)

    def isprime(n):
        return all(n%i !=0 for i in xrange(2, math.sqrt(n)+1) ) if n > 0 else False

    def remove(head):
        if not head: return None
        head.next = remove(head.next)
        return head.next if isprime(head.val) else head

11) SUM OF POWERS TECHNIQUE

    Sum of numbers from 1 to n -> (1/2) * n * (n+1)
    Sum of squares from 1 to n inclusive -> (1/6) * n * (n+1) * (2n + 1)
    Sum of cubes from 1 to n inclusive -> 
        (Sum of numbers from 1 to N) ^ 2 == ( (1/2)* n * (n+1)) ^ 2

12) FAST EXPONENTIATION TECHNIQUE:

    a^n = 1 if n == 0
    a^n = a if n == 1
    a^n = (a^(n/2))^2 is n is even
    a^n = a*(a^((n-1)/2) )^2 if n is odd
    => recursive implementation is O(log n)

13) Linear algebra:
    -> Solve system, invert a matrix, find the rank of matrix, compute determinant,
    -> all the above can be done with gaussian elimination

14) Cross Product Use Cases:

    - Determining the (signed) area of a triangle
    - Test if three points are collinear
    - Determining the orientation of three points
    - Testing if two line segments intersect

    Define ccw(A, B, C) = (B-A) X (C-A) = (bx - ax)(cy - ay) - (by - ay)(cx - ax)
    ccw(A, B, C) > 0 implies A->B->C is a left turn
    ccw(A, B, C) < 0 implies A->B->C is a right turn

    Segment - Segment Intersection Test:
    Given 2 segments AB and CD, determine if they intersect property, 2 segments
    meet at a signle point that are strictly inside both segments

    Assume they intersect: 
    - From A's point of view, looking straight to B, C, D must lie on different sides
    - Holds true for the other segment as well. 
    Intersection exists and is proper if:
    - ccw(A, B, C) X ccw(A, B, D) < 0 and ccw(C, D, A) X ccw(C, D, B) < 0

    Also:
    if ccw(A, B, C), ccw(A, B, D), ccw(C, D, A), and ccw(C, D, B) are all zeros, then two 
    segments are collinear


15) Convex Hull 
    Given n points on the plane, fill the smallest convex polygon that contains all the given 
    points. 
    - FOr simplicity, assume that no 3 points are collinear

    Simple Algo:
    AB is an edge of the convex hull iff ccw(A, B, C) have the same sign for all other points C
    - This gives us a simple algo
    For each A and B: 
        - If ccw(A, B, C) > 0 for all C != A, B:
            - Record the edge A->B 

    -> Walk along the recorded edges to recover the convex hull
    
    -> Faster algo: Graham Scan
    We know that the leftmost given point has to be in the convex hull
    - assume unique leftmost point
    make the leftmost point the origin, so that all other points have positive x coords
    sort the points in increasing order of y/x
        -> increasing order of angle, whatever you like to call it
    incrementally construct the convex hull usign a stack

    We maintain a convex chain of the given points
    for each i, do the following: (i's are processed in order of increasing angle)
        - Append point i to the current chain
        - If the new point causes a concave corner, remove the bad vertex fromt the chain
            that causes it (pop from chain, until its convex again)
        - repeat until the new chain becomes convex
    
    Pseudocode:
    Set the leftmost point as (0,0), and sort the rest of the points in increasing order of y/x
    Initialize the stack s
    For i = 1, .., n
        - Let A be the second topmost element of S, B be the topmost element of S, and C be the 
          ith point
        - If ccw(A, B, C) < 0, pop S and go back
        - push C to S

    -> Points in S form the convex hull
    
16) SWEEP LINE ALGORITHM: (Mix this algorithm with interval scheduling, and 2 pointer techniques!)
    A problem solving strat for geometry problems.
    main idea: maintain a line (with some auxilary data structure) that sweeps through the entire
    plane and solves the problem locally
    -> We cant simulate a continuous process (e.g. sweeping a line) so we define events that cause
    certain changes in our data structure
        - And process the events in the order of occurence
    
    Example Problem: given n axis-aligned rectangesl, find the area of the union of the them.
    We weill sweep the plane from left to right
    Events: left and right edges of the rectangles
    THe main idea is to maintain the set of "active" rectanges in order
        -It suffices to store the y-coords of the rectangles. 
    
    Psuedo-pseudo code

    If the sweep line hits the left edges of a rectangle
        - Insert it to a data structure
    Right edge?
        - Remove it
    -> Move to the next event, and add the area(s) of the green rectangle(s)
        - Finding the length of the union of the blue segments is the hardest step
        - THere is an easy O(n) method for this step (blue edges represent current active parts)

    Sweep algo notes:
    Generic concept. Come up with the right set of events and data structures for each problem
    Exercise problems:
    - Finding the perimeter of the union of rectangles
    - Finding all k intersections of n line segments in O( (n+k)lgn ) time



17) Intersecting Half Planes:
    Representing a half-plane: ax + by + c <= 0
    The intersection of half-places is a convex area
        - if the intersection is bounder, it gives a convex polygon
    
    Give n half-planes, how do we compute the intersection of them?
        - i.e. FInd the vertices of the convex rea
    -> Easy O(n^3) algo and hard O(nlgn) one

    Easy way:
    For each half plane aix + biy +ci <= 0, define a straight line ei = aix+biy + ci = 0
    For each pair ei and ej:
        - Compute the intersection p = (px, py)
        - Check if akpx + bkpy + ck <= 0 for all half planes
            -> if so, store p in some array P
            -> otherwise discard p

    Find convex hull of the points in P
    
    -> Interesction of half-places can be unbounded
        - But usually, we are given limits on the min/max vals of the coordinates
        - Add four half planes:
            x>= -M, x<= M, y>= -M, y<= M to ensure intersection is bounded
    Time complex: O(n^3)

18) BINARY SEARCH: use it to find the largest circle that fits into a given polygon
        -Dont try to find a closed form soln or anything like that!

19) Ternary search:
    Can use to:
        Find the minimum point of a "convex" function f
            - Not exactly convex but lets use this word anyway
        
        Initialize search interval [s, e]
        Until "e-s" becomes small enough:

            - m1 = s + (e-s)/3, m2 = e - (e-s)/3
            - If f(m1) <= f(m2), set e = m2
            - otherwise: set s = m1





 


###################################################3



#################################################################################################################

COOL Notes PART 2: Bit Magic

0.1) How to set a bit in a number:
        void set(int & num,int pos) 
    { 
         // First step is shift '1', second 
         // step is bitwise OR 
         num |= (1 << pos); 
    }     

0.2) How to unset/clear a bit at nth position in the number:
        // First step is to get a number that  has all 1's except the given position. 
        void unset(int &num,int pos) 
        { 
            //Second step is to bitwise and this  number with given number 
            num &= (~(1 << pos)); 
        } 

0.3) Toggle bit an nth position (use xor for toggling)
        // First step is to shift 1,Second step is to XOR with given number 
        void toggle(int &num,int pos) 
        { 
            num ^= (1 << pos); 
        } 


0.4) Checking if bit at nth position is set or unset: It is quite easily doable using ‘AND’ operator. 
        Left shift ‘1’ to given position and then ‘AND'(‘&’).

        bool at_position(int num,int pos) 
        { 
            bool bit = num & (1<<pos); 
            return bit; 
        } 

0.5) Inverting every bit of a number/1’s complement (this is how to get 1s complement):
        If we want to invert every bit of a number i.e change bit ‘0’ to ‘1’ and bit ‘1’ to ‘0’.
        We can do this with the help of ‘~’ operator. For example : if number is num=00101100 (binary representation) 
        so ‘~num’ will be ‘11010011’.

0.6) Get twos complement: complement of a number is 1’s complement + 1.
    So formally we can have 2’s complement by finding 1s complement and adding 1 
    to the result i.e (~num+1) or what else we can do is using ‘-‘ operator.
        int main() 
        { 
            int num = 4; 
            int twos_complement = -num; 
            cout << "This is two's complement " << twos_complement << endl; 
            cout << "This is also two's complement " << (~num+1) << endl; 
            return 0; 
        } 

0.7) Stripping off the lowest set bit: 

        In many situations we want to strip off the lowest set bit for example in 
        Binary Indexed tree data structure, counting number of set bit in a number.

        We do something like this:

        X = X & (X-1)

        Let us see this by taking an example, let X = 1100.

        (X-1)  inverts all the bits till it encounter lowest set ‘1’ 
        and it also invert that lowest set ‘1’.

        X-1 becomes 1011. After ‘ANDing’ X with X-1 we get lowest set bit stripped.

0.8) Getting lowest set bit of a number:
        This is done by using expression ‘X &(-X)’
        Let us see this by taking an example:Let X = 00101100. 
        So ~X(1’s complement) will be ‘11010011’ and 2’s complement will 
        be (~X+1 or -X) i.e  ‘11010100’.
        So if we ‘AND’ original number ‘X’ with its 
        two’s complement which is ‘-X’, we get lowest set bit.
        
        int lowest_set_bit(int num) 
        { 
            int ret = num & (-num); 
            return ret; 
        } 

0.9) We have considered below facts in this article –

        0 based indexing of bits from left to right.
        Setting i-th bit means, turning i-th bit to 1
        Clearing i-th bit means, turning i-th bit to 0

1.0) Clear all bits from LSB to ith bit
        mask = ~((1 << i+1 ) - 1);
        x &= mask;

        Logic: To clear all bits from LSB to i-th bit, we have to AND x with mask having LSB to i-th bit 0. 
                To obtain such mask, first left shift 1 i times. Now if we minus 1 from that, 
                all the bits from 0 to i-1 become 1 and remaining bits become 0. Now we can 
                simply take complement of mask to get all first i bits to 0 and remaining to 1.
                
                x = 29 (00011101) and we want to clear LSB to 3rd bit, total 4 bits
                mask -> 1 << 4 -> 16(00010000)
                mask -> 16 – 1 -> 15(00001111)
                mask -> ~mask -> 11110000
                x & mask -> 16 (00010000)

1.1) Clearing all bits from MSB to i-th bit

        mask = (1 << i) - 1;
        x &= mask;
       
        x = 215 (11010111) and we want to clear MSB to 4th bit, total 4 bits
        mask -> 1 << 4 -> 16(00010000)
        mask -> 16 – 1 -> 15(00001111)
        x & mask -> 7(00000111)
1.2) Divide by 2
     x >>= 1;
    Multiply by 2
    x <<= 1;

1.3) Upper case English alphabet to lower case

        ch |= ' ';

1.4) Lower case English alphabet to upper case
    
        ch &= '_’ ;

1.5) 7) Count set bits in integer

        int countSetBits(int x) 
        { 
            int count = 0; 
            while (x) 
            { 
                x &= (x-1); 
                count++; 
            } 
            return count; 
        } 

1.6) Find log base 2 of 32 bit integer

        int log2(int x) 
        { 
            int res = 0; 
            while (x >>= 1) 
                res++; 
            return res; 
        } 

1.7) Checking if given 32 bit integer is power of 2

        int isPowerof2(int x) 
        { 
            return (x && !(x & x-1)); 
        } 
        Logic: All the power of 2 have only single bit set e.g. 16 (00010000). 
        If we minus 1 from this, all the bits from LSB to set bit get toggled, 
        i.e., 16-1 = 15 (00001111). Now if we AND x with (x-1) and the result 
        is 0 then we can say that x is power of 2 otherwise not. 
        We have to take extra care when x = 0.

        Example
        x = 16(000100000)
        x – 1 = 15(00001111)
        x & (x-1) = 0
        so 16 is power of 2



1.9) The left shift and right shift operators should not be used for negative numbers 
If any of the operands is a negative number, it results in undefined behaviour. 
For example results of both -1 << 1 and 1 << -1 is undefined. Also, if the number 
is shifted more than the size of integer, the behaviour is undefined. For example, 
1 << 33 is undefined if integers are stored using 32 bits. See this for more details.



2) [Leetcode A-summary:-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently ]
    Set union A | B
    Set intersection A & B
    Set subtraction A & ~B
    Set negation ALL_BITS ^ A or ~A
    Set bit A |= 1 << bit
    Clear bit A &= ~(1 << bit)
    Test bit (A & 1 << bit) != 0
    Extract last bit A&-A or A&~(A-1) or x^(x&(x-1))
    Remove last bit A&(A-1)
    Get all 1-bits ~0

2.1) Is power of 4:

        bool isPowerOfFour(int n) {
            return !(n&(n-1)) && (n&0x55555555);
            //check the 1-bit location;
        }

2.2) ^ tricks
Use ^ to remove even exactly same numbers and save the odd, 
or save the distinct bits and remove the same.

2.3) Sum of Two Integers
        Use ^ and & to add two integers

        int getSum(int a, int b) {
            return b==0? a:getSum(a^b, (a&b)<<1); //be careful about the terminating condition;
        }

2.4) | tricks
        Keep as many 1-bits as possible

        Find the largest power of 2 (most significant bit in binary form), 
        which is less than or equal to the given number N.

        long largest_power(long N) {
            //changing all right side bits to 1.
            N = N | (N>>1);
            N = N | (N>>2);
            N = N | (N>>4);
            N = N | (N>>8);
            N = N | (N>>16);
            return (N+1)>>1;
        }

2.5) Reverse bits of a given 32 bits unsigned integer.

        uint32_t reverseBits(uint32_t n) {
            unsigned int mask = 1<<31, res = 0;
            for(int i = 0; i < 32; ++i) {
                if(n & 1) res |= mask;
                mask >>= 1;
                n >>= 1;
            }
            return res;
        }

        uint32_t reverseBits(uint32_t n) {
            uint32_t mask = 1, ret = 0;
            for(int i = 0; i < 32; ++i){
                ret <<= 1;
                if(mask & n) ret |= 1;
                mask <<= 1;
            }
            return ret;
        }

2.6) & tricks. Just selecting certain bits

        Reversing the bits in integer

        x = ((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1);
        x = ((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2);
        x = ((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4);
        x = ((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8);
        x = ((x & 0xffff0000) >> 16) | ((x & 0x0000ffff) << 16);


2.7) Bitwise AND of Numbers Range
Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND 
of all numbers in this range, inclusive. 
For example, given the range [5, 7], you should return 4.

        int rangeBitwiseAnd(int m, int n) {
            int a = 0;
            while(m != n) {
                m >>= 1;
                n >>= 1;
                a++;
            }
            return m<<a; 
        }

2.8) Number of 1 Bits Write a function that takes an unsigned integer 
    and returns the number of ’1' bits it has (also known as the Hamming weight).

        int hammingWeight(uint32_t n) {
            int count = 0;
            while(n) {
                n = n&(n-1);
                count++;
            }
            return count;
        }

        int hammingWeight(uint32_t n) {
            ulong mask = 1;
            int count = 0;
            for(int i = 0; i < 32; ++i){ //31 will not do, delicate;
                if(mask & n) count++;
                mask <<= 1;
            }
            return count;
        }

2.9) Application
Repeated DNA Sequences
All DNA is composed of a series of nucleotides abbreviated as 
A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, 
it is sometimes useful to identify repeated sequences within the DNA. 
Write a function to find all the 10-letter-long sequences (substrings) 
that occur more than once in a DNA molecule.
For example,

        Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",
        Return: ["AAAAACCCCC", "CCCCCAAAAA"].


        class Solution {
        public:
            vector<string> findRepeatedDnaSequences(string s) {
                int sLen = s.length();
                vector<string> v;
                if(sLen < 11) return v;
                char keyMap[1<<21]{0};
                int hashKey = 0;
                for(int i = 0; i < 9; ++i) hashKey = (hashKey<<2) | (s[i]-'A'+1)%5;
                for(int i = 9; i < sLen; ++i) {
                    if(keyMap[hashKey = ((hashKey<<2)|(s[i]-'A'+1)%5)&0xfffff]++ == 1)
                        v.push_back(s.substr(i-9, 10));
                }
                return v;
            }
        };

        But the above solution can be invalid when repeated sequence appears too many times, 
        in which case we should use unordered_map<int, int> 
        keyMap to replace char keyMap[1<<21]{0}here.

3.0) Majority Element
        Given an array of size n, find the majority element. 
        The majority element is the element that appears more than ⌊ n/2 ⌋ times. 
        (bit-counting as a usual way, but here we actually 
        also can adopt sorting and Moore Voting Algorithm)

        Solution
        int majorityElement(vector<int>& nums) {
            int len = sizeof(int)*8, size = nums.size();
            int count = 0, mask = 1, ret = 0;
            for(int i = 0; i < len; ++i) {
                count = 0;
                for(int j = 0; j < size; ++j)
                    if(mask & nums[j]) count++;
                if(count > size/2) ret |= mask;
                mask <<= 1;
            }
            return ret;
        }


3.1) Single Number III
        Given an array of integers, every element appears three 
        times except for one. Find that single one. (Still this type 
        can be solved by bit-counting easily.)
        But we are going to solve it by digital logic design

        Solution
        //inspired by logical circuit design and boolean algebra;
        //counter - unit of 3;
        //current   incoming  next
        //a b            c    a b
        //0 0            0    0 0
        //0 1            0    0 1
        //1 0            0    1 0
        //0 0            1    0 1
        //0 1            1    1 0
        //1 0            1    0 0
        //a = a&~b&~c + ~a&b&c;
        //b = ~a&b&~c + ~a&~b&c;
        //return a|b since the single number can appear once or twice;

        int singleNumber(vector<int>& nums) {
            int t = 0, a = 0, b = 0;
            for(int i = 0; i < nums.size(); ++i) {
                t = (a&~b&~nums[i]) | (~a&b&nums[i]);
                b = (~a&b&~nums[i]) | (~a&~b&nums[i]);
                a = t;
            }
            return a | b;
        };



3.2) Maximum Product of Word Lengths
        Given a string array words, find the maximum value of length(word[i]) * length(word[j]) 
        where the two words do not share common letters. 
        You may assume that each word will contain only lower case letters. 
        If no such two words exist, return 0.

        Example 1:
        Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]
        Return 16
        The two words can be "abcw", "xtfn".

        Example 2:
        Given ["a", "ab", "abc", "d", "cd", "bcd", "abcd"]
        Return 4
        The two words can be "ab", "cd".

        Example 3:
        Given ["a", "aa", "aaa", "aaaa"]
        Return 0
        No such pair of words.

        Solution
        Since we are going to use the length of the word very frequently and we are to compare 
        the letters of two words checking whether they have some letters in common:

        using an array of int to pre-store the length of each word reducing the frequently measuring process;
        since int has 4 bytes, a 32-bit type, and there are only 26 different letters, so we can just use 
        one bit to indicate the existence of the letter in a word.

        int maxProduct(vector<string>& words) {
            vector<int> mask(words.size());
            vector<int> lens(words.size());
            for(int i = 0; i < words.size(); ++i) lens[i] = words[i].length();
            int result = 0;
            for (int i=0; i<words.size(); ++i) {
                for (char c : words[i])
                    mask[i] |= 1 << (c - 'a');
                for (int j=0; j<i; ++j)
                    if (!(mask[i] & mask[j]))
                        result = max(result, lens[i]*lens[j]);
            }
            return result;
        }

        Attention
        result after shifting left(or right) too much is undefined
        right shifting operations on negative values are undefined
        right operand in shifting should be non-negative, otherwise the result is undefined
        The & and | operators have lower precedence than comparison operators
        Sets

3.3) All the subsets

        A big advantage of bit manipulation is that it is trivial 
        to iterate over all the subsets of an N-elemen
        set: every N-bit value represents some subset. 
        Even better, if A is a subset of B then the number
        representing A is less than that representing B, which 
        is convenient for some dynamic programming solutions.

        It is also possible to iterate over all the subsets of a 
        particular subset (represented by a bit pattern), provided 
        that you don’t mind visiting them in reverse order 
        (if this is problematic, put them in a list as they’re 
        generated, then walk the list backwards). The trick 
        is similar to that for finding the lowest bit in a number. 
        If we subtract 1 from a subset, then the lowest set element 
        is cleared, and every lower element is set. However, we only 
        want to set those lower elements that are in the superset. 
        So the iteration step is just i = (i - 1) & superset.

        vector<vector<int>> subsets(vector<int>& nums) {
            vector<vector<int>> vv;
            int size = nums.size(); 
            if(size == 0) return vv;
            int num = 1 << size;
            vv.resize(num);
            for(int i = 0; i < num; ++i) {
                for(int j = 0; j < size; ++j)
                    if((1<<j) & i) vv[i].push_back(nums[j]);   
            }
            return vv;
        }
        Actually there are two more methods to handle this using recursion and iteration respectively.

        Bitset
        A bitset stores bits (elements with only two possible values: 0 or 1, true or false, ...).
        The class emulates an array of bool elements, but optimized for space allocation: 
        generally, each element occupies only one bit (which, on most systems, 
        is eight times less than the smallest elemental type: char).

        // bitset::count
        #include <iostream>       // std::cout
        #include <string>         // std::string
        #include <bitset>         // std::bitset

        int main () {
            std::bitset<8> foo (std::string("10110011"));
            std::cout << foo << " has ";
            std::cout << foo.count() << " ones and ";
            std::cout << (foo.size()-foo.count()) << " zeros.\n";
            return 0;
        }


3.9) The bitwise operators should not be used in place of logical operators.

4) The left-shift and right-shift operators are equivalent to multiplication and division by 2 respectively.
As mentioned in point 1, it works only if numbers are positive.

5) The & operator can be used to quickly check if a number is odd or even
The value of expression (x & 1) would be non-zero only if x is odd, otherwise the value would be zero.

6) The ~ operator should be used carefully
The result of ~ operator on a small number can be a big number if the result is stored in an
unsigned variable. And result may be negative number if result is stored in signed 
variable (assuming that the negative numbers are stored in 2’s complement 
form where leftmost bit is the sign bit)


-> X ^ 0s = x
-> X ^ 1s = ~x
x ^ x = 0

7) Compute XOR from 1 to n (direct method) :

        // Direct XOR of all numbers from 1 to n 
        int computeXOR(int n) 
        {
        	if (n % 4 == 0) 
        		return n; 
        	if (n % 4 == 1) 
        		return 1; 
        	if (n % 4 == 2) 
        		return n + 1; 
        	else
        		return 0; 
        } 

8) We can quickly calculate the total number of combinations with numbers smaller than or
   equal to with a number whose sum and XOR are equal. Instead of using looping 
   (Brute force method), we can directly find it by a mathematical trick i.e.

    // Refer Equal Sum and XOR for details.
    Answer = pow(2, count of zero bits)

9) How to know if a number is a power of 2?
        // Function to check if x is power of 2 
        bool isPowerOfTwo(int x) 
        { 
        	// First x in the below expression is 
        	// for the case when x is 0 
        	return x && (!(x & (x - 1))); 
        } 

10) Find XOR of all subsets of a set. We can do it in O(1) time. 
    The answer is always 0 if given set has more than one elements. 
    For set with single element, the answer is value of single element. 

11) We can quickly find number of leading, trailing zeroes and number of 1’s 
    in a binary code of an integer in C++ using GCC. 
    It can be done by using inbuilt function i.e.
  
    Number of leading zeroes: builtin_clz(x)
    Number of trailing zeroes : builtin_ctz(x)
    Number of 1-bits: __builtin_popcount(x) 
    Refer GCC inbuilt functions for details.

12) Convert binary code directly into an integer in C++.
        // Conversion into Binary code// 
        #include <iostream> 
        using namespace std; 
        
        int main() 
        { 
            auto number = 0b011; 
            cout << number; 
            return 0; 
        } 
        Output: 3


13) Simple approach to flip the bits of a number: It can be done by a simple way, 
    just simply subtract the number from the value obtained when all the bits are equal to 1 .


14) We can quickly check if bits in a number are in alternate pattern (like 101010). 
    We compute n ^ (n >> 1). If n has an alternate pattern, then n ^ (n >> 1) operation 
    will produce a number having set bits only. ‘^’ is a bitwise XOR operation. 

COOL NOTES PART 3: USING XOR TO SOLVE PROBLEMS EXAMPLES: ####################################

1) You are given a list of n-1 integers and these integers are in the range of 1 to n. 
There are no duplicates in list. One of 
the integers is missing in the list. Write an efficient code to find the missing integer.

METHOD 2(Use XOR)

  1) XOR all the array elements, let the result of XOR be X1.
  2) XOR all numbers from 1 to n, let XOR be X2.
  3) XOR of X1 and X2 gives the missing number.


2) How to swap two numbers without using a temporary variable?
   Given two variables, x and y, swap two variables without using a third variable.

   int main() 
{ 
    int x = 10, y = 5; 
  
    // Code to swap 'x' and 'y' 
    x = x + y; // x now becomes 15 
    y = x - y; // y becomes 10 
    x = x - y; // x becomes 5 
    cout << "After Swapping: x =" << x << ", y=" << y; 
} 

OR:  (WITH XOR)

int main() 
{ 
    int x = 10, y = 5; 
    // Code to swap 'x' (1010) and 'y' (0101) 
    x = x ^ y; // x now becomes 15 (1111) 
    y = x ^ y; // y becomes 10 (1010) 
    x = x ^ y; // x becomes 5 (0101) 
    cout << "After Swapping: x =" << x << ", y=" << y; 
    return 0; 
} 

3) XOR Linked List – A Memory Efficient Doubly Linked List | Set 1

An ordinary Doubly Linked List requires space for two address 
fields to store the addresses of previous and next nodes. 
A memory efficient version of Doubly Linked List can be 
created using only one space for address field with every node. 
This memory efficient Doubly Linked List is called XOR Linked List 
or Memory Efficient as the list uses bitwise XOR operation to save space 
for one address. In the XOR linked list, instead of storing actual memory 
addresses, every node stores the XOR of addresses of previous and next nodes.

Traversal of XOR Linked List:
We can traverse the XOR list in both forward 
and reverse direction. While traversing the 
list we need to remember the address of 
the previously accessed node in order to 
calculate the next node’s address. 
For example when we are at node C, we must have address of 
B. XOR of add(B) and npx of C gives us the add(D). The reason 
is simple: npx(C) is “add(B) XOR add(D)”. If we do xor of npx(C) 
with add(B), we get the result as “add(B) XOR add(D) XOR add(B)” 
which is “add(D) XOR 0” which is “add(D)”. So we have the address of next node. 
Similarly we can traverse the list in backward direction.

4) Find the two non-repeating elements in an array of repeating elements

    Let x and y be the non-repeating elements we are looking for and arr[] be the input array.
    First, calculate the XOR of all the array elements.

        xor = arr[0]^arr[1]^arr[2].....arr[n-1]
    All the bits that are set in xor will be set in one non-repeating 
    element (x or y) and not in others. So if we take any set bit of xor 
    and divide the elements of the array in two sets – one set of elements
    with same bit set and another set with same bit not set. By doing so, 
    we will get x in one set and y in another set. Now if we do XOR of all 
    the elements in the first set, we will get the first non-repeating element,
    and by doing same in other sets we will get the second non-repeating element.

    Let us see an example.
    arr[] = {2, 4, 7, 9, 2, 4}
    1) Get the XOR of all the elements.
        xor = 2^4^7^9^2^4 = 14 (1110)
    2) Get a number which has only one set bit of the xor.   
    Since we can easily get the rightmost set bit, let us use it.
        set_bit_no = xor & ~(xor-1) = (1110) & ~(1101) = 0010
    Now set_bit_no will have only set as rightmost set bit of xor.
    3) Now divide the elements in two sets and do xor of         
    elements in each set and we get the non-repeating 
    elements 7 and 9. Please see the implementation for this step.
    /* Now divide elements in two sets by comparing rightmost set 
   bit of xor with bit at same position in each element. */
    for(i = 0; i < n; i++) 
    { 
        if(arr[i] & set_bit_no) 
        *x = *x ^ arr[i]; /*XOR of first set */
        else
        *y = *y ^ arr[i]; /*XOR of second set*/
    } 

5)   Find the two numbers with odd occurrences in an unsorted array
        # Python3 program to find the 
        # two odd occurring elements 
        
        # Prints two numbers that occur odd 
        # number of times. The function assumes 
        # that the array size is at least 2 and 
        # there are exactly two numbers occurring 
        # odd number of times. 
        def printTwoOdd(arr, size): 
            
            # Will hold XOR of two odd occurring elements  
            xor2 = arr[0]  
            
            # Will have only single set bit of xor2 
            set_bit_no = 0  
            n = size - 2
            x, y = 0, 0
        
            # Get the xor of all elements in arr[].  
            # The xor will basically be xor of two 
            # odd occurring elements  
            for i in range(1, size): 
                xor2 = xor2 ^ arr[i] 
        
            # Get one set bit in the xor2. We get  
            # rightmost set bit in the following  
            # line as it is easy to get  
            set_bit_no = xor2 & ~(xor2 - 1) 
        
            # Now divide elements in two sets:  
            # 1) The elements having the corresponding bit as 1.  
            # 2) The elements having the corresponding bit as 0.  
            for i in range(size): 
            
                # XOR of first set is finally going to   
                # hold one odd  occurring number x  
                if(arr[i] & set_bit_no): 
                    x = x ^ arr[i] 
        
                # XOR of second set is finally going  
                # to hold the other odd occurring number y  
                else: 
                    y = y ^ arr[i]  
        
            print("The two ODD elements are", x, "&", y) 
        
        # Driver Code 
        arr = [4, 2, 4, 5, 2, 3, 3, 1] 
        arr_size = len(arr) 
        printTwoOdd(arr, arr_size) 
    

6) Add two numbers without using arithmetic operators

        Write a function Add() that returns sum of two integers. 
        The function should not use any of the arithmetic operators (+, ++, –, -, .. etc).
        Sum of two bits can be obtained by performing XOR (^) of the two bits. 
        Carry bit can be obtained by performing AND (&) of two bits.
        Above is simple Half Adder logic that can be used to add 2 single bits.
        We can extend this logic for integers. If x and y don’t have set bits at same position(s), 
        then bitwise XOR (^) of x and y gives the sum of x and y. To incorporate common set bits also, 
        bitwise AND (&) is used. Bitwise AND of x and y 
        gives all carry bits. We calculate (x & y) << 1 and 
        add it to x ^ y to get the required result.

        # Python3 Program to add two numbers 
        # without using arithmetic operator 
        def Add(x, y): 
        
            # Iterate till there is no carry  
            while (y != 0): 
            
                # carry now contains common 
                # set bits of x and y 
                carry = x & y 
        
                # Sum of bits of x and y where at 
                # least one of the bits is not set 
                x = x ^ y 
        
                # Carry is shifted by one so that    
                # adding it to x gives the required sum 
                y = carry << 1
            
            return x 
        
        print(Add(15, 32)) 
  
7. Count number of bits to be flipped to convert A to B

        Given two numbers ‘a’ and b’. Write a program to count number 
        of bits needed to be flipped to convert ‘a’ to ‘b’.

        1. Calculate XOR of A and B.      
                a_xor_b = A ^ B
        2. Count the set bits in the above 
            calculated XOR result.
                countSetBits(a_xor_b)

        # Function that count set bits 
        def countSetBits( n ): 
            count = 0
            while n: 
                count += n & 1
                n >>= 1
            return count 
            
        # Function that return count of 
        # flipped number 
        def FlippedCount(a , b): 
        
            # Return count of set bits in 
            # a XOR b 
            return countSetBits(a^b) 
        
        # Driver code 
        a = 10
        b = 20
        print(FlippedCount(a, b)) 

8.      Find the element that appears once. Given an array where every element occurs three times, 
        except one element which occurs only once. Find the element that occurs once.

        Run a loop for all elements in array. At the end of every iteration, maintain following two values.

        ones: The bits that have appeared 1st time or 4th time or 7th time .. etc.

        twos: The bits that have appeared 2nd time or 5th time or 8th time .. etc.

        Finally, we return the value of ‘ones’

        How to maintain the values of ‘ones’ and ‘twos’?
        ‘ones’ and ‘twos’ are initialized as 0. For every new element in array, 
        find out the common set bits in the new element and previous value of ‘ones’. 
        These common set bits are actually the bits that should be added to ‘twos’. 
        So do bitwise OR of the common set bits with ‘twos’. ‘twos’ also gets 
        some extra bits that appear third time. These extra bits are removed later.
        Update ‘ones’ by doing XOR of new element with previous value of ‘ones’.
        There may be some bits which appear 3rd time. These extra bits are also removed later.

        Both ‘ones’ and ‘twos’ contain those extra bits which appear 3rd time. 
        Remove these extra bits by finding out common set bits in ‘ones’ and ‘twos’.



        Below is the implementation of above approach:

        # Python3 code to find the element that  
        # appears once 

        def getSingle(arr, n): 
            ones = 0
            twos = 0

            for i in range(n): 
                # one & arr[i]" gives the bits that 
                # are there in both 'ones' and new 
                # element from arr[]. We add these 
                # bits to 'twos' using bitwise OR 
                twos = twos | (ones & arr[i]) 

                # one & arr[i]" gives the bits that 
                # are there in both 'ones' and new 
                # element from arr[]. We add these 
                # bits to 'twos' using bitwise OR 
                ones = ones ^ arr[i] 

                # The common bits are those bits  
                # which appear third time. So these 
                # bits should not be there in both  
                # 'ones' and 'twos'. common_bit_mask 
                # contains all these bits as 0, so 
                # that the bits can be removed from 
                # 'ones' and 'twos' 
                common_bit_mask = ~(ones & twos) 

                # Remove common bits (the bits that  
                # appear third time) from 'ones' 
                ones &= common_bit_mask 

                # Remove common bits (the bits that 
                # appear third time) from 'twos' 
                twos &= common_bit_mask 
            return ones 

        # driver code 
        arr = [3, 3, 2, 3] 
        n = len(arr) 
        print("The element with single occurrence is ", 
                getSingle(arr, n)) 

9. Detect if two integers have opposite signs

        Given two signed integers, write a function that returns true if the signs of 
        given integers are different, otherwise false. For example, the function 
        should return true -1 and +100, and should return false for -100 and -200. 
        The function should not use any of the arithmetic operators.

        Let the given integers be x and y. The sign bit is 1 in negative numbers, 
        and 0 in positive numbers. The XOR of x and y will have the sign bit as 1 
        iff they have opposite sign. In other words, XOR of x and y will be negative 
        number number iff x and y have opposite signs. The following code use this logic.

        # Python3 Program to Detect  
        # if two integers have  
        # opposite signs. 
        def oppositeSigns(x, y): 
            return ((x ^ y) < 0); 

        x = 100
        y = 1

        if (oppositeSigns(x, y) == True): 
            print "Signs are opposite"
        else: 
            print "Signs are not opposite"

10. Return the rightmost 1 in the binary representation of a number.
        Example: For 1010, you should perform some operations to give 0010 as the output. 
        For 1100, you should give 0100. Similarly for 0001, you should return 0001.
    
        For this problem, you need to know a property of binary subtraction. 
        Check if you can find out the property in the examples below,

        1000 – 0001 = 0111
        0100 – 0001 = 0011
        1100 – 0001 = 1011

        The property is, the difference between a binary number n and n-1 
        is all the bits on the right of the rightmost 1 are flipped 
        including the rightmost 1.  
        Using this amazing property, we can get our solution as
        x ^ (x & (x - 1))
        
        You now already know 80% about a powerful data structure called 
        Fenwick Tree or Binary Indexed Tree. You can look up on it to 
        learn the 20% or let me know if you want my next article to be about it. )
