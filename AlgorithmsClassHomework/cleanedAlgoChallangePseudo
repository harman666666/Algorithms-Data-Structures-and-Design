Challenge #10: Paths in graphs

Consider the following problem: given an unweighted directed graph G, and nodes s and t, 
decide whether there exist at least two directed SIMPLE paths from s to t of 
different lengths. Is the problem solvable in polynomial time, or is it NP-complete?


##########################################################################################################################################################

The problem is solvable in polynomial time. 

The following is the algorithm :

We will make a reversed version of the graph G and call this G' 

The algorithm makes use of a subgraph of G we call shortestPathsDAG. 
shortestPathsDAG is a DAG which contains all the shortest paths of equal length from S to T in G.

The number of shortest paths between two nodes in a graph is super exponential.
We can build a structure that holds these paths cheaply, 
avoiding the super exponential runtime. 
shortestPathsDAG will be this structure and we will use it to 
generate any shortest path we desire in linear time.
shortestPathsDAG will start with S, its root, and have multiple paths come out of S, which all end at T. 
Utilizing shortestPathsDAG effectively will allow us to solve the algorithmic challenge 
in polynomial time. Finally, our subgraph called shortestPathsDAG can be built in linear time.
The linear time algorithm is covered below; a quick rundown of the algorithm to build shortestPathsDAG would be the following:
Run BFS on S to get the shortest path from S to every vertex. Run BFS on the reversed graph from T, to get the shortest
path from every vertex to T. Then enumerate all the vertices X in the graph besides S and T, and check if  [S->X->T] is 
the same length as the shortest length path between S and T and if it is, add all of [S->X->T]'s vertices, and edges 
to the shortestPathsDAG. Once all the vertices have been enumerated, shortestPathsDAG contains all the shortest paths between S and T.  

There are 2 ways to create longer paths using shortestPathsDAG:
1) First way is called Lost Edge Method.
   One way is to check every vertex in shortestPathsDAG to see if there is an edge, E, 
   between that vertex and another vertex in shortestPathsDAG 
   that hasn't been added to shortestPathsDAG. (In other words E is not 
   in the set of edges of shortestPathsDAG)
   This edge was not added because it was not in any of the shortest paths 
   we found in the algorithm above to construct shortestPathsDAG. 
   Finding such an edge, we call them LOST_EDGES_IN_THE_DAG or LOST_EDGES, will trivally make a longer path:
   Assume the 2 vertices with the LOST_EDGE is X and Y in the shortestPathsDAG, and the LOST_EDGE goes from X to Y.
   Then the longer path is [S->X, LOST_EDGE, Y->T]. 
   LOST_EDGE was not included in the DAG because it does not help a path 
   get closer from S to T (so cannot be a forward edge in shortestPathsDAG).
   Therefore, LOST_EDGE can only make the path longer, because it is either a cross edge 
   or a backward edge in the shortestPathsDAG. Therefore [S->X, LOST_EDGE, Y->T] is a longer path.
   (The exact algorithm to find a lost edge and use it is 
   discussed in PseudoCode below, and that algorithm is linear time)

2)  Second way is called Outer Vertex Method. 
    A longer path requires vertices to be used outside of shortestPathsDAG.
    To create the longer path we have one very strong condition: 
    It must leave a vertex of the shortestPathsDAG, go through some edges not in the 
    shortestPathsDAG (these edges will be called the CRAZY SEGMENT), 
    and then come back to a vertex in the shortestPathsDAG. The path from S to the ExitPoint (called X), 
    X to the Rentry point back into the shortestPathsDAG (called Y), and Y to T will be a possible long path to consider. 
    There is only 1 Exit Point (we will call this X from now on), 
    and 1 Reentry point(we will case this Y from now on) when we create a longer path 
    (So every long path we consider will have only 1 crazy segment).
    In the proof of correctness we explain why you only need 1 X and 1 Y (and not 2, 3, etc).
    
    We can only find paths of longer length with this approach
    because shortestPathsDAG already contains all the shortest paths between S and T.

How do we discover crazy segments and make longer paths?
All we need to do is find X and Y on the shortestPathsDAG (X and Y are vertices
in the shortestPathsDAG. X and Y are also the intersection points between shortestPathsDAG and the CRAZY SEGMENT).
To do this, we test all the vertices in {G vertices}-{shortestPathsDAG vertices} 
and on each vertex Z, run BFS starting on Z, on the graph(G) to find Y 
(call this CrazyBFS. Store all the Y's you find in an array called possibleYFromZ), 
and run BFS starting on Z, on the reverse of the graph(G') to find X 
(call this ReverseCrazyBFS. Store all the X's you find in an array called possibleXToZ). 

The crazy segment is a path running from one of the X's to Z to one of the Y's. 
We do BFS on the reverse graph to get X, 
because this is the EXIT POINT out of the 
DAG from S to reach Z (The EXIT POINT can also be S in which case S == X). 
We do normal BFS on the graph to get Y, because this will 
find an entry point into the DAG from Z to finally reach T
(The RENTRY POINT can also be T in which case Y == T). 

So the CRAZY SEGMENT is [X -> Z -> Y], and the longer path we can create will be [S->X->Z->Y->T]
The Z we use is called the COORDINATION POINT, because it is where X and Y sprout from in the algorithm. 

(We will later see we wont have to run CrazyBFS and ReverseCrazyBFS 
on every vertex in {G vertices}-{shortestPathsDAG vertices}, 
but actually just a very few number) 

Lets discuss what the {G vertices}-{shortestPathsDAG vertices} 
looks like, call this set subtraction verticesToTest.
verticesToTest are vertices that are in the graph that 
weren't used to construct a path from s to t. We have to use these
vertices, and the edges between them to get a longer path. 
These edges form a forest of components sprawled around the 
shortestPathsDAG. We have to test these components, 
and throw them out if they don't identify a path of longer length.

(We will also later see what happens when Y topologically comes before X in the shortestPathsDAG)
Finally 

The core idea of pseudocode below: 

To find CrazySegment, we go through verticesToTest, 
and do crazy BFS, and reverse crazy BFS.

Steps: 

1) Run reverse crazy BFS to find possibleXToZ with vertex Z on the graph.
2) Run crazy BFS to find possibleYFromZ with vertex Z on the graph. 



3) If we dont find any X, dont find any Y, or dont find either, then we can reduce verticesToTest getting us closer to algorithm termination: 
   If we dont find any X, then there are no exit points that lead out from the DAG to Z.  
   This also means there are no exit points that lead out from the DAG to the vertices visited by the reverse crazy BFS on Z. 
   (Otherwise, we would have found an X that reaches Z).
    We can remove all the vertices we traversed in the reverse crazy BFS from verticesToTest.  

    Similarly, if we dont find any Y, then there are no re-entry points that lead from Z back into the DAG.
    This also means there are no re-entry points that lead into the DAG using Z's visited vertices.  
    (Otherwise, we would have found a Z that reaches Y).
    We can remove all the vertices we traversed in the crazy BFS from verticesToTest. 



4) If we found one or more X and one or more Y(So len(possibleXToZ) > 0 and len(possibleYFromZ) > 0):

    For each X in possbleXToZ:
        For each Y in possibleYFromZ:
            if( X != Y): 
                The BFSTree touches the shortestPathsDAG in two places, called X and Y in the shortestPathsDAG. 
                We can CREATE a new path (PLEASE LOOK AT ALGO BELOW TO SEE LONGER PATH CREATION ALGORITHM). 
                path = createLongerPath(S, T, X, Y, CRAZYSEGMENT, shortestPathsDAG)
                
                The NEW path is [S->X, X->Z->Y, Y->T], called Q.


                A) Q's length is longer than the shortest length. We are done. 
                    We found 2 simple paths of different length, the shortest one, and [S->X, X->Z->Y, Y->T].


                B) PATH [S-X, X->Z->Y, Y->T] could not be created. (For reasons why a path can't be created look at below algorithm).
                    We memoize the results of why the path could not be created, so next time, we know not to pick those memoized X and Y (and some 
                    of the points between X and Y in the DAG), as entry and exit points. We memoize the results in a map of sets called invalidXY.
                    invalidXY states all invalid Y vertices for every vertex X.    
                    We also rerun the above CrazyBFS and ReverseCrazyBFS on the same Z, and try to find a different Y for the X. 



If we run out of verticesToTest, we have exhausted all possible longer paths that could have existed, and return False.


LONGER PATH CREATION ALGORITHM (RUN THIS ALGO ONCE WE GET X AND Y)
There are a few cases to consider when creating the path:

1) What if X == Y. This wont happen. We will find X first, and then we will find Y such that X != Y in our BFS.
2) What if we find Y and X, and  Y topologically comes before X? 
   So that the following is the arrangement after topological assortment of the DAG: [S, Y, Z, X, T]
    -> The path will still be [S-X->Z->Y->T]
    -> This can still work sometimes because DAGs have multiple branching paths you can traverse to get from S to T!
    -> We will try to create the path, and if it fails path creation, forget the path we found and continue with the algorithm:
    -> To create the longer path we run DFS to get a path from S->X and we run DFS to get a path from Y->T on the DAG
        -> If Y comes topologically after X, there wont be a problem because CRAZY SEGMENT will be forward edges from X to Y and the DAG 
           points forward from S to T
        -> If Y comes topologically before X, there may be a problem because CRAZY SEGMENT will be backward edges from X to Y 
           so the path from Y->T may intersect with the path from S->X (we cannot have this happen because it must be a SIMPLE Path)
        -> The create path algorithm will assume the Y before X scenerio because it works on the X before Y scenerio:
            1) DFS from S->X on shortestPathsDAG and get a path, and store visited vertices in visitedX. if S->X DFS see's vertex Y, ignore it.  
            2) Then DFS from Y->T on shortestPathsDAG without visiting of the vertices from from visitedX  or X. 
                2a) If T is reached done. 
                2b) Otherwise T was not reached.
                    3) Lift restriction that Y->T path can't use visitedX, and try to use visitedX vertices to get to T (DFS still cant visit X). 
                       If T still cant be reached because Y->T path still sees X, then FAIL PATH CREATION.
                       If T is reached. We need to do DFS 1 final time on S->X and attempt to get path, without seeing Y or visitedY.
                       4a) S->X worked. Then Done. 
                       4b) S->X did not work. The piece of the path we gave up to Y->T was the only segment we could use to go 
                           from S->X without seeing Y or its vertices. Y->T needed it too, otherwise, 
                           the previous DFS would have suggested another way for Y to reach T.   
                           Fail Path Creation due to contention for this piece of critical segment in the DAG both S->X and Y->T need. 

    -> The above path creation algorithm uses 3 DFS's in the very worst case.






##################################################################################################
WHAT DO WE DO WITH FAILED PATHS?

The problem with failed paths is that they are not truly failed paths until the DAG 
has all its shortest paths. Becaues the DAG currently does not


is save that path somewhere, keep running the algo to find other shortest paths. 
then finish, and at the end of the algo test all these failed paths one more time


Okay here is an algo to get all the shortest paths from s to t to build the shortest path DAG.



    In the end we have created a structure that contains all enumerations of shortest paths from S to T in linear time.  



#############################################################################
PROGRAM CORRECTNESS:

shortestPathsDAG enumerates only shortest paths i.e., shortestPathsDAG does not contain longer paths. 



To create a longer path only requires using 2 vertices in DAGraph 
(and using more vertices for something like 2 crazy paths is not something we need to search for):



shortestPathsDAG will be used to construct a longer path. 



Lost Edges are cross edges or backward edges and finding a lost 
edge means we found a longer path.


Lost Edges Method and Outer Vertex Method each find a set of longer paths, and these 
2 sets are mutually exclusive and the set addition is all the possible longer paths in the graph
between S and T.



########################################################################################################################################################3
Running Time.

The algorithm does BFS at the beginning. O(V+E).
In the very worst case, the algorithm does BFS on every vertex, and only manages to reduce by 2 vertices and two edges.
This happens when the shortest path is length 2 (cant be 1 because that would cause case 1 of CRAZY SEGMENT BFS), 
and we keep getting length 2 shortest paths to add to the DAG.
This would cause a worst case of |V| * O(V+E)


AVERAGE CASE:
Otherwise it does BFS for a few components. If there are k components, and each component has P vertices, and Q edges, k*O(P+Q).
However, the sum of all the P's is bounded by V, and the sum of all the Q's is bounded by E. So this can be seen as one big BFS, and becomes O(V+E) 
The average case runtime is therefore: O(V+E). 

##########################################################################################################################################################


PSEUDO_CODE:

// THIS IS HELPER FUNCTION 1
// RUNTIME: 2 BFS calls. 
// 
def buildShortPathsDAG(G, S, T):
    -> Run BFS and get shortest paths from s to every vertex in G. 
        ->Store parentsS[], and distS[] for this BFS.
    -> Reverse the graph and run BFS to get the shortest path from every vertex to T. 
        ->Store parentsT[], and distT[] for this BFS.
    -> Ok store length of shortest path from S to T, call it shortestLength 
        ->(get from one of the BFS's).

       verticesTestedToBeInShortestDAG := All the vertices in the graph except S and T:  
       
       shortestPathsDAG = {} //Adjacency List using Map

       For each vertex X in verticesTestedToBeInShortestDAG: 
            Find distance from vertex X to S (using  DistS[X]). 
            Find distance from vertex X to T (using DistT[X]). 
            Add them to find the distance of path [S->X->T] called length
                if length == shortestLength, 
                    -> construct path [S->X->T] using parentsS and parentsT
                    -> add the path [S->X->T] to the shortestPathsDAG  
                    -> remove all the vertices we added in the path from verticesTestedToBeInShortestDAG



// THIS IS HELPER FUNCTION 2
// A LOST EDGE is an edge between 2 vertices in the shortestPathDAG that wasn't added to shortestPathDAG
// RUNTIME: Go through every vertex, and check every neighbour worst case.
// So worst case runtime is O(sum of the degree of every vertex in G)  -> O(|E||V|)
def createLongerPathUsingLostEdges(G, shortestPathsDAG):
    
    setOfVerticesInDAG = shortestPathDAG vertices
    // Set look up is fast.

    for each vertex v in setOfVerticesInDAG:
        all_neighbours = G[v]
        dag_neighbours = shortestPathsDAG[v]

        other_neighbours = all_neighbours - dag_neighbours

        for each k in other_neighbours:
            if(k is in setOfVerticesInDAG):
                return True // We found a lost edge. REPORT THAT 2 PATHS OF DIFFERENT SIZE EXIST.
                            // Lost edge creates [S->V, V->K, K->T] which is longer than shortest path 
                            // (check correctness proof for this)
    
    return False //Could not find any lost edges.




//THIS IS HELPER FUNCTION 3. WE USE THIS TO DO CRAZYBFS AND REVERSECRAZYBFS
def crazyBFS(Graph, vertex, shortestPathsDAG):  // HELPER FUNCTION DEFINED HERE.
    dist[s] := 0;
    Q := empty queue;
    visited = set()
     
    intersectionVertex = None
    for all u in V do
        dist[u] := infinity;
        pi[u] := nil;
    
    enqueue(Q, s);
    while (Q is nonempty) do
        u := dequeue(Q);
        if(u in visited):
            continue
        else: 
            visited.add(u)
        if(u in shortestPathsDAG vertices): //This is map look up O(1)
            intersectionVertex = u
            break
        for all edges (u,v) in Graph do //Out neighbours traversed (Directed BFS)
            enqueue(Q,v)
            dist[v] := dist[u]+1;
            pi[v] := u;
    //When intersection vertex is None, we did not find an intersection with DAG.
    return ({"dist": dist,
             "pi": pi, 
             "visited": visited, 
             "intersectionVertex": intersectionVertex
             })

// THIS IS HELPER FUNCTION 4. WE USE THIS TO CREATE THE LONGER PATH AFTER FINDING X AND Y.
// X is the exit point of the DAG
// Y is the re-entry point into the DAG
// Z is the coordination point (the point we run crazy bfs and reverse crazy bfs on)
// s is the root of the DAG 
// t is the end of the DAG.
def createLongerPath(s, t, X, Y, CRAZYSEGMENT, shortestPathsDAG):
    
    <create path and check its length. The path is [S->X, X->COMMONPARENT, COMMONPARENT->Y, Y->T]>
                        STEPS TO GET NEW PATH: 
                        to get edges from (S->X), go backward from X to S in the DAG by traversing any parent vertices, 
                            they will all lead to the root of the shortestPathsDAG which is S. 
                        //(can maintain a DAG in the reverse direction so we just move forward to S from X)
                        Create (X->Y) easily by just doing  [ X->COMMONPARENT, COMMONPARENT->Y]
                        Y to T is trivial, just move forward in DAGraph to get edges. 
    visited = 



//THIS IS THE MAIN FUNCTION THAT SOLVES THE ALGORITHMIC CHALLENGE:
def two_paths(G, s, t):
    shortestPathsDAG = map()
    ReverseG := Reverse the graph G

    for all u in V do
        dist[u] := infinity;
        pi[u] := nil;
    
    dist[s] := 0;
    
    Q := empty queue;
    
    enqueue(Q, s);

    Do BFS, get shortest st path, add st path to shortestPathsDAG.

    shortestPathLength = length(st-path);

    verticesToTest = set() = G vertices - shortestPathsDAG vertices

    //START FINDING CRAZY SEGMENTS.

    testNewVertex = FALSE
    vertex = verticesToTest.pop();  //Set remove a random element to be the first 


    while(true): // Go through all the vertices in verticesToTest and find X and Y using ReverseCrazyBFS and CrazyBFS

        if(testNewVertex = TRUE):
              vertex = verticesToTest.pop();  
              testNewVertex = FALSE

        XResult = crazyBFS(ReverseG, vertex, shortestPathsDAG) //We have to BFS on reverse graph to find exit point out of DAG
        YResult = crazyBFS(G, vertex, shortestPathsDAG) //We BFS on normal graph to find entry point into DAG
        

        if(XResult.intersection is not None and YResult.intersection is not None): // THIS IS CASE 3. We have found a crazy segment a possible longer path!!!

            // PATH IS [S->X->Z->Y->T]
            CRAZYSEGMENT = Create Path From X to Z to Y 
                             -> Create using ancestors of X stored in XResult.pi to Z.
                             -> Create using ancestors of Y stored in YResult.pi to Z.
                             -> Combine 2 and that is CrazySegment.

            NEWPATH = createLongerPath(s, t, X, Y, CRAZYSEGMENT, shortestPathsDAG)

            if NEWPATH length is same as shortestPathLength:
                NEWPATH added to shortestPathsDAG
                verticesToTest -= vertices of NEWPATH // REMOVE VERTICES IN NEW PATH WE FOUND.
            else:
                RETURN TRUE (2 PATHS ARE NEWPATH AND shortest STPATH)

        else: //Either X could not be found, or Y could not be found, or neither could be found. 
            if(XResult.intersection is None):
                // X could not be found which means no exit point out of DAG 
                // All the vertices we saw in the BFS will not be able to find exit points either
                // so remove all of them as potential COORDINATION POINTS
                verticesToTest -= XResult.visited
                testNewVertex = TRUE
            if(YResult.intersection is None):
                // Y could not be found which means no REENTRY point into the DAG 
                // All the vertices we see also cannot find a REENTRY POINT INTO DAG 
                // so remove all of them as potential COORDINATION POINTS
                verticesToTest -= YResult.visited; //REMOVE ALL VISITED VERTICES.
                testNewVertex = TRUE;


    RETURN FALSE (All vertices were checked, and longer path was not found)

################################################################################################################################

'''
CORRECTNESS PROOF (work in progress):


The shortest ST-Path was found using BFS. 

We save these vertices in DAGVertices. 
The DAGVertices are the vertices for the graph. 
Let DAGVertices be shortest paths that go from S to T.


All the vertices not in DAGVertices are edges that can be used to elongate the path from S to T.
All the vertices not in DAGVertices is a forest of subgraphs. 


Lets look at all the possibilities for these subgraphs that can be used to generate a longer path: 


    If the subgraph is not connected to the shortestPATHDAG at all (it was a seperate component), 
    then the twostep BFS will identify it and remove it from the verticesToTest
    
    If the subgraph is connected to the shortestPATHDAG, 
    We run TWOSTEP BFS on a vertex U in verticesToTest:

        Case 1: No vertex in the shortestPATHDAG is found:    
            This case is impossible because the graph is connected.

        Case 2: 1 vertex in the shortestDAG Graph is found: 
            One intersection vertex cannot be used to elongate a path, because 2 nodes
            are needed to go into a CRAZY SEGMENT and leave CRAZY SEGMENT to go to T
           
            All vertices that were discovered in the BFS of U will be 
            removed from verticesToTest because they will all lead to this case 
            (1 vertex in the shortestDAG Graph case).

        Case 3: 2 vertices in the shortestDAG Graph is found:
            A new path can be formed by doing [S->X, X->COMMON_PARENT, COMMON_PARENT->Y, Y->T]
            If the new path is the same size as the shortest path, 
                add the path to DAGVertices, and to the DAG Graph
                remove the vertices of newPath from verticesToTest 

            If the new path is longer, return True

'''

#